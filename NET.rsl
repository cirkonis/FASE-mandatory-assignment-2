scheme NET =
class
  type 
    Time = Nat, 
    Headway = Time, 
    DrivingTime = Time, 
    Capacity = Nat,
    StopId = Text, 
    Connection = (Stop >< Stop >< Headway >< Capacity >< DrivingTime),
    Stop = (StopId >< Capacity),
    Net = (Stop-list >< Connection-list)

  value /* generators */
    empty :  Net = (<..>, <..>), 


    insertStop : StopId >< Capacity >< Net -> Net
    insertStop(stp,cap,net) is
    let (sl,cl)=net, h=sl ^ <.(stp,cap).> in
    <.(h,cl).>
    end,


    -- add a connection between given stops, 
    -- with the given minimum headway, capacity and minimum driving time
    addConnection : StopId >< StopId  >< Headway >< Capacity >< DrivingTime >< Net -> Net
    addConnection(startid, stpid, hw, c, dt, net) is
    let (sl,cl) = net, stpidOne = getStop(startid, sl), stpidTwo = getStop(stpid, sl) in
    (sl, cl ^ <.(stpidOne, stpidTwo, hw, c, dt).>)
    end



    -- aux function get stop 

    getStop: StopId >< Stop-list -> Stop
    getStop(stpId, stpList) is 
    if stpList = <..> then ("", null)
        else
        let stp = hd(stpList), (si, c) = stp in
        if stopId = si then stp
        else 
            getStop(stpId, tl(stpList)) 
        end
        end
    end,
    

    insertStop : StopId >< Capacity >< Net -> Net
    insertStop(stp,cap,net) is
    let (sl,cl)=net, h=sl union <.(stp,cap).> in
    <.(h,cl).>
    end


  value /* observers */
   
    getStop : StopId >< Stop-list -> Stop
    getStop(stpid, sl) is
    if sl = <..>
      then ("",null)
    else
      let stp = hd(sl), (si,c)=stp in
        if stpid = si
          then stop
        else
          getStop(stpid,tl(sl))
        end
      end
    end
    
end
/*
    isIn : StopId >< Net -> Bool
    isIn(stpId, Net) is
    let stopList = hd(net) in
*/

    -- get the capacity of a stop 
    capacity : StopId >< Net -~-> Capacity
    ...,

    -- check whether two stops are directly connected in a network        
    areDirectlyConnected : StopId >< StopId >< Net -> Bool
    ...,

    -- get minimum headway between two connected stops        
    minHeadway : StopId >< StopId >< Net -~-> Headway
    ..., 

   -- get the capacity for a connection between two connected stops
    capacity : StopId >< StopId >< Net -~-> Capacity
    ...,
 
    -- get minimum driving time between two connected stops        
    minDrivingTime : StopId >< StopId >< Net -~-> DrivingTime
    ...

 
  value
    isWellformed : Net -> Bool
    isWellformed(n) is ...
/*